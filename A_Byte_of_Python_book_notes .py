# Заметки по книге A Byte of Python
from colorama import init
from colorama import Fore, Back, Style


init()

print(Fore.WHITE)
print("Program start")

# 7.4.6 Метод format
name = "Andrey"
age = 35
print("Hello! My name is {0}, i'm {1} years old.".format(name, age))

# Десятичное (.) число с точностью в 3 знака для плавающих
print("{0:.3}".format(1/3))

# Заполнить подчеркиваниями (_) с ценровкой текста (^) по ширине 11
print("{0:_^11}".format("Hello"))

# По ключевым словам
print("{name} написал книгу {book}".format(name="Swaroop", book="A Byte of Python"))

# 7.8.1 Пример: Использование переменных и констант
# "i" - переменная, "5" - константа, "=" - оператор присваивания
i = 5
print(i)
i = i + 1
print(i)
# "s" - переменная, "строка" - константа, "=" - оператор присваивания
s = '''Это многострочная строка. 
Это вторая её строчка.'''
print(s)

# 7.9 Логические и физические строки
# Чтобы записать более одной логической строки на одной физической строке, вам придётся 
# явно указать это при помощи точки с запятой (;),
# Окончание логической строки можно обозначать символом ";"
i = 5
print(i)
# то же самое, что
i = 5;
print(i);
# и то же самое может быть записано в виде
i = 5; print(i);
# или даже
i = 5; print(i)

# Пример, который называется явным объединением строк
s = 'Это строка. \
Это строка продолжается.'
print(s) # OUT: Это строка. Это строка продолжается.
# Аналогично,
print\
(i)
# то же самое, что и
print(i)

# 8.1 Операторы
'''
ОПЕРАТОР 	НАЗВАНИЕ 		ОБЪЯСНЕНИЕ 			ПРИМЕРЫ
----------------------------------------------------------------------------------------------------
	+ 		Сложение 		Суммирует два		3 + 5 даст 8; 'a' + 'b' даст 'ab'
							объекта
	- 		Вычитание		Даёт разность		-5.2 даст отрицательное число,
							двух чисел; если	а 50 - 24 даст 26
							отсутствует, он
							считается
							равным нулю
	* 		Умножение		Даёт произведение	2 * 3 даст 6. 'la' * 3 даст 'lalala'
							двух чисел или
							возвращает
							строку,
							повторённую
							заданное число
							раз.
	** 		Возведение в    Возвращает			3 ** 4 даст 81 (т.е. 3 * 3 * 3 * 3)
			степень			число х,
							возведённое в
							y степень
	/ 		Деление			Возвращает			4 / 3 даст 1.3333333333333333
							частное от
							деления x на y
	// 		Целочисленное	Возвращает			4 // 3 даст 1. -4 // 3 даст -2
			деление			неполное
							частное от
							деления
	%		Деление по  	Возвращает			8 % 3 даст 2. -25.5 % 2.25 даст 1.5
			модулю			остаток от
							деления		
	<<		Сдвиг			Сдвигает биты		2 << 2 даст 8. В двоичном виде 2
			влево			числа влево на      представляет собой 10. Сдвиг влево на 2
							заданное			бита даёт 1000, что в десятичном виде
							количество			означает 8.
							позиций.
							(Любое число в
							памяти
							компьютера
							представлено в
							виде битов - или
							двоичных
							чисел, т.е. 0 и 1)
	>> 		Сдвигает		Сдвигает биты		11 >> 1 даст 5. В двоичном виде 11
			вправо			числа вправо на     представляется как 1011, что будучи
							заданное число      смещённым на 1 бит вправо, даёт 101, а
							позиций.			это, в свою очередь, не что иное как
												десятичное 5
	& 		Побитовое		Побитовая			5 & 3 даёт 1.
			И               операция И над
							числами
	|		Побитовое		Побитовая			5 | 3 даёт 7
			ИЛИ             операция ИЛИ
                            над числами
	^ 		Побитовое		Побитовая			5 ^ 3 даёт 6
			ИСКЛЮЧИТЕЛЬНО	операция ИС-
			ИЛИ             КЛЮЧИТЕЛЬНО
                            ИЛИ
	~ 		Побитовое		Побитовая			~5 даёт -6.
			НЕ              операция НЕ
							для числа x
							соответствует
							-(x+1)
    < 		Меньше			Определяет,			5 < 3 даст False,
							верно ли, что x		а 3 < 5 даст True.
                            меньше y. Все		Можно составлять произвольные цепочки
                            операторы			сравнений: 3 < 5 < 7 даёт True
                            сравнения
							возвращают
                            True или
                            False1.
	>		Больше			Определяет,			5 > 3 даёт True. Если оба операнда -
							верно ли, что x		числа, то перед сравнением они оба
							больше y            преобразуются к одинаковому типу. В
                                                противном случае всегда возвращается
				                                False.
	<= 		Меньше			Определяет,	        x = 3; y = 6; x <= y даёт True.
            или равно		верно ли, что x
                            меньше или
                            равно y	
    >=      Больше          Определяет,         x = 4; y = 3; x >= 3 даёт True.
            или равно       верно ли, что x
                            больше или
                            равно y
    ==      Равно           Проверяет,          x = 2; y = 2; x == y даёт True. x =
							одинаковы ли        'str'; y = 'stR'; x == y даёт False.
                            объекты             x = 'str'; y = 'str'; x == y даёт
                                                True.
    !=      Не равно		Проверяет,          x = 2; y = 3; x != y даёт True.
                            верно ли, что
                            объекты не
                            равны
    not     Логическое      Если x равно        x = True; not x даёт False.
            НЕ              True, оператор
							вернёт False.
							Если же x равно		
							False, получим
							True.
	and 	Логическое      x and y даёт        x = False; y = True; x and y
            И               False, если x	    возвращает False, поскольку x равно
                            равно False , в     False. В этом случае Python не станет
                            противном           проверять значение y, так как уже знает,
                            случае              что левая часть выражения „and“
                            возвращает          равняется False, что подразумевает, что
                            значение y          и всё выражение в целом будет равно
												False, независимо от значений всех
												остальных операндов. Это называется
												укороченной оценкой булевых
												(логических) выражений.
	or 		Логическое      Если x равно		x = True; y = False; x or y даёт
            ИЛИ             True, в 			True. Здесь также может производиться
							результате  		укороченная оценка выражений.
							получим True, в
							противном
							случае получим
							значение y
'''
# 8.2 Порядок вычисления
# Таблица: Приоритет операторов (от нижнего к верхнему).
'''
ОПЕРАТОР			    ОПИСАНИЕ
-------------------------------------------------------------------------------------------------
lambda                 |Лямбда-выражение
or                     |Логическое «ИЛИ»
and                    |Логическое «И»
not x                  |Логическое «НЕ»
in, not in             |Проверка принадлежности
is, is not             |Проверка тождественности
<, <=, >, >=, !=, ==   |Сравнения
|                      |Побитовое «ИЛИ»
^                      |Побитовое «ИСКЛЮЧИТЕЛЬНО ИЛИ»
&                      |Побитовое «И»
<<, >>                 |Сдвиги
+, -                   |Сложение и вычитание
*, /, //, %            |Умножение, деление, целочисленное деление и остаток от деления
+x, -x                 |Положительное, отрицательное
~x                     |Побитовое НЕ
**                     |Возведение в степень
x.attribute            |Ссылка на атрибут
x[индекс]              |Обращение по индексу
x[индекс1:индекс2]     |Вырезка
f(аргументы ...)       |Вызов функции
(выражения, ...)       |Связка или кортеж
[выражения, ...]       |Список
{ключ:данные, ...}     |Словарь
'''

# 8.5 Выражения
length = 5
breadth = 2
area = length * breadth
print("Площадь равна", area)
print("Периметр равен", 2 * (length + breadth))
'''OUT:
Площадь равна 10
Периметр равен 14
'''

# 9.1 Оператор if
number = 23
guess = int(input("Введите целое число : "))
if guess == number:
	print("Поздравляю, вы угадали,") # Начало нового блока
	print("хотя и не выиграли никакого приза!") # Конец нового блока
elif guess < number:
	print("Нет, загаданное число больше этого.") # Ещё один блок
# Внутри блока вы можете выполнять всё, что угодно ...
else: # guess > number
	print("Нет, загаданное число меньше этого.")

print("Завершено") # Это последнее выражение выполняется всегда после выполнения оператора if

# 9.2 Оператор while
number = 23
running = True
while running:
	guess = int(input("Введите целое число : "))

	if guess == number:
		print("Поздравляю, вы угадали.")
		running = False # это останавливает цикл while
	elif guess < number:
		print("Нет, загаданное число немного больше этого.")
	else:
		print("Нет, загаданное число немного меньше этого.")
else:
	print("Цикл while закончен.") # Здесь можете выполнить всё что вам ещё нужно

print("Завершение.")

# 9.3 Цикл for
for i in range(1, 5): # последовательность чисел [1,2,3,4]
	print(i)
else:
	print("Цикл for закончен")
# Чтобы увидеть всю последовательность чисел сразу, используйте list(range()).
list(range(1, 5))
print(range(1, 5)) # последовательность чисел [1,2,3,4]

# 9.4 Оператор break
while True:
	s = input("Введите что-нибудь: ")
	if s == "выход":
		break
	print("Длина строки:", len(s))
print("Завершение")

# 9.5 Оператор continue
while True:
	s = input("Введите что-нибудь: ")
	if s == "выход":
		break
	if len(s) < 3:
		print("Слишком мало символов")
		continue
	print("Введённая строка достаточной длины")

# 10 Функции
def sayHello():
	print("Привет, Мир!") # блок, принадлежащий функции

sayHello() # вызов функции
sayHello() # ещё один вызов функции

# 10.1 Параметры функций
def printMax(a, b): # parametr
	if a > b:
		print(a, "максимально")
	elif a == b:
		print(a, "равно", b)
	else: # a < b
		print(b, "максимально")

printMax(3, 4) # прямая передача значений
# OUT: 4 максимально

x = 5
y = 7
printMax(x, y) # передача переменных в качестве аргументов
# OUT: 7 максимально

# 10.2 Локальные переменные
x = 50
def func(x):
	print("x равен", x)
	x = 2
	print("Замена локального x на", x)

func(x)
print("x по-прежнему равен", x)
# OUT:
'''
x равен 50
Замена локального x на 2
x по-прежнему равен 50
'''

# 10.3 Зарезервированное слово «global»
x = 50
def func():
	global x # слово global позволяет объявить x – это глобальная переменная
	print("x равно", x)
	x = 2
	print("Заменяем глобальное значение x на", x)

func()
print("Значение x составляет", x)
# OUT:
'''
x равно 50
Заменяем глобальное значение x на 2
Значение x составляет 2
'''

# 10.4 Зарезервированное слово «nonlocal»
def func_outer():
	x = 2
	print("x равно", x)
	def func_inner():
		nonlocal x
		x = 5
	func_inner()
	print("Локальное x сменилось на", x)

func_outer()
# OUT:
'''
x равно 2
Локальное x сменилось на 5
'''

# 10.5 Значения аргументов по умолчанию
def say(message, times=1):
	print(message * times)

say("Привет")
say("Мир", 5) # указываем аргумент 5, обозначая, что мы хотим сказать фразу 5 раз.
# OUT:
'''
Привет
МирМирМирМирМир
'''

# 10.6 Ключевые аргументы
def func(a, b=5, c=10):
	print("a равно", a, ", b равно", b, ", а c равно", c)

func(3, 7)
func(25, c=24)
func(c=50, a=100)
# OUT:
'''
a равно 3, b равно 7, а c равно 10
a равно 25, b равно 5, а c равно 24
a равно 100, b равно 5, а c равно 50
'''

# 10.7 Переменное число параметров
def total(a=5, *numbers, **phonebook):
	print("a", a)
	# проход по всем элементам кортежа
	for single_item in numbers:
		print("single_item", single_item)
	# проход по всем элементам словаря
	for first_part, second_part in phonebook.items():
		print(first_part, second_part)
print(total(10, 1, 2, 3, Jack=1123, John=2231, Inge=1560))
# OUT:
'''
a 10
single_item 1
single_item 2
single_item 3
Jack 1123
John 2231
Inge 1560
None
'''

# 10.8 Только ключевые параметры
def total(initial=5, *numbers, extra_number):
	count = initial
	for number in numbers:
		count += number
	count += extra_number
	print(count)

total(10, 1, 2, 3, extra_number=50)
total(10, 1, 2, 3)
# Вызовет ошибку, поскольку мы не указали значение
# аргумента по умолчанию для 'extra_number'.
# OUT:
'''
66
Traceback (most recent call last):
    File "keyword_only.py", line 10, in <module>
total(10, 1, 2, 3)
TypeError: total() missing 1 required keyword-only argument: 'extra_number'
'''

# 10.9 Оператор «return»
def maximum(x, y):
	if x > y:
		return x
	elif x == y:
		return "Числа равны."
	else: # x < y
		return y

print(maximum(2, 3))
# OUT:
'''
3
'''

# !!!Каждая функция содержит в неявной форме оператор return None в конце
def someFunction():
	pass

print(someFunction())
# OUT:
'''
None
'''

# 10.10 Строки документации
def printMax(x, y):
	# docstrings:
	'''Выводит максимальное из двух чисел.

	Оба значения должны быть целыми числами.'''
	x = int(x) # конвертируем в целое число, если возможно
	y = int(y)

	if x > y:
		print(x, "наибольшее")
	else:
		print(y, "наибольшее")
		
printMax(3, 5)
print(printMax.__doc__)
# OUT:
'''
5 наибольшее
Выводит максимальное из двух чисел.

	Оба значения должны быть целыми числами.
'''

# Узнать текущий каталог программы:
import os

print(os.getcwd())
# OUT: D:\python\test

# 11.3 Имя модуля – __name__
if __name__ == "__main__":
	# если запустить к примеру test.py
	print("Программа запущена сама по себе.")
else:
	# если сделать import test (или import math)
	print("Программа импортирована в другой модуль.")

# 11.4 Создание собственных модулей
'''
!!! каждая программа на Python также является и модулем, если у неё установлено расширение .py !!!
'''
# Напишем модуль test.py
def sayhi():
	print("Привет! Это говорит мой модуль.")

__version__ = '0.1'
# Конец модуля test.py

'''
!!! Помните, что модуль должен находиться либо в том же каталоге, что и программа,
в которую мы импортируем его, либо в одном из каталогов, указанных в sys.path !!!
'''

# напишем к примеру test_demo.py
import test

test.sayhi()
print("Версия", test.__version__)

# запустим test_demo.py
# OUT:
'''
Привет! Это говорит мой модуль.
Версия 0.1
'''

# Вот версия, использующая синтаксис from..import (сохраним как test_demo2.py):
from test import sayhi, __version__

sayhi()
print("Версия", __version__)
# OUT test_demo2.py такой же, как и test_demo.py

# 12.2 Краткое введение в объекты и классы
# Это мой список покупок
shoplist = ["яблоки", "манго", "морковь", "бананы"]
print("Я должен сделать", len(shoplist), "покупки.")
print("Покупки:", end=" ")

for item in shoplist:
	print(item, end=" ")

print("\nТакже нужно купить рис.")
shoplist.append("рис")
print("Теперь мой список покупок таков:", shoplist)

print("Отсортирую-ка я свой список.")
shoplist.sort()
print("Отсортированный список покупок выглядит так:", shoplist)

print("Первое, что мне нужно купить, это", shoplist[0])
olditem = shoplist[0]
del shoplist[0]
print("Я купил", olditem)
print("Теперь мой список покупок:", shoplist)
# OUT:
'''
Я должен сделать 4 покупки.
Покупки: яблоки манго морковь бананы
Также нужно купить риса.
Теперь мой список покупок таков: ['яблоки', 'манго', 'морковь', 'бананы',
'рис']
Отсортирую-ка я свой список
Отсортированный  список покупок выглядит так: ['бананы', 'манго', 'морковь',
'рис', 'яблоки']
Первое, что мне нужно купить, это бананы
Я купил бананы
Теперь мой список покупок: ['манго', 'морковь', 'рис', 'яблоки']
'''

# 12.3 Кортеж
zoo = ("питон", "слон", "пингвин") # помните, что скобки в кортеже не обязательны
print("Количество животных в зоопарке -", len(zoo))
new_zoo = "обезьяна", "верблюд", zoo
print("Количество клеток в зоопарке -", len(new_zoo))
print("Все животные в новом зоопарке:", new_zoo)
print("Животные, привезённые из старого зоопарка:", new_zoo[2])
print("Последнее животное, привезённое из старого зоопарка -", new_zoo[2][2])
print("Количество животных в новом зоопарке -", len(new_zoo)-1 + \
	len(new_zoo[2]))
# OUT:
'''
Количество животных в зоопарке - 3
Количество клеток в зоопарке - 3
Все животные в новом зоопарке: ('обезьяна', 'верблюд', ('питон', 'слон', 'пингвин'))
Животные, привезённые из старого зоопарка: ('питон', 'слон', 'пингвин')
Последнее животное, привезённое из старого зоопарка - пингвин
Количество животных в новом зоопарке - 5
'''

# 12.4 Словарь
ab = {
	'Swaroop' : 'swaroop@swaroopch.com',
	'Larry' : 'larry@wall.org',
	'Matsumoto' : 'matz@ruby-lang.org',
	'Spammer' : 'spammer@hotmail.com'
	}

print("Адрес Swaroop'а:", ab['Swaroop'])

# Удаление пары ключ-значение
del ab['Spammer']

print("\nВ адресной книге {0} контакта\n".format(len(ab)))

for name, address in ab.items():
	print("Контакт {0} с адресом {1}".format(name, address))

# Добавление пары ключ-значение
ab['Guido'] = 'guido@python.org'

if 'Guido' in ab:
	print("\nАдрес Guido:", ab['Guido'])
# OUT:
'''
Адрес Swaroop'а: swaroop@swaroopch.com

В адресной книге 3 контакта

Контакт Swaroop с адресом swaroop@swaroopch.com
Контакт Matsumoto с адресом matz@ruby-lang.org
Контакт Larry с адресом larry@wall.org

Адрес Guido: guido@python.org
'''

# 12.5 Последовательности
shoplist = ['яблоки', 'манго', 'морковь', 'бананы']
name = 'swaroop'

# Операция индексирования
print("Элемент 0 -", shoplist[0])
print("Элемент 1 -", shoplist[1])
print("Элемент 2 -", shoplist[2])
print("Элемент 3 -", shoplist[3])
print("Элемент -1 -", shoplist[-1])
print("Элемент -2 -", shoplist[-2])
print("Символ 0 -", name[0])
# OUT:
'''
Элемент 0 - яблоки
Элемент 1 - манго
Элемент 2 - морковь
Элемент 3 - бананы
Элемент -1 - бананы
Элемент -2 - морковь
Символ 0 - s
'''

# Вырезка из списка
print("Элементы с 1 по 3:", shoplist[1:3])
print("Элементы с 2 до конца:", shoplist[2:])
print("Элементы с 1 по -1:", shoplist[1:-1])
print("Элементы от начала до конца:", shoplist[:])
# OUT:
'''
Элементы с 1 по 3: ['манго', 'морковь']
Элементы с 2 до конца: ['морковь', 'бананы']
Элементы с 1 по -1: ['манго', 'морковь']
Элементы от начала до конца: ['яблоки', 'манго', 'морковь', 'бананы']
'''

# Вырезка из строки
print("Символы с 1 по 3:", name[1:3])
print("Символы с 2 до конца:", name[2:])
print("Символы с 1 до -1:", name[1:-1])
print("Символы от начала до конца:", name[:])
# OUT:
'''
Символы с 1 по 3: wa
Символы с 2 до конца: aroop
Символы с 1 до -1: waroo
Символы от начала до конца: swaroop
'''

# 12.6 Множество
>>> bri = set(['Бразилия', 'Россия', 'Индия'])
>>> 'Индия' in bri
True
>>> 'США' in bri
False
>>> bric = bri.copy()
>>> bric.add('Китай')
>>> bric.issuperset(bri) # Проверяет наличие/вхождение всех элементов последовательности в множество.
True
>>> bri.remove('Россия')
>>> bri.intersection(bric) # OR bri & bric 
{'Бразилия', 'Индия'}

# 12.7 Ссылки
print("Простое присваивание.")
shoplist = ['яблоки', 'манго', 'морковь', 'бананы']
mylist = shoplist # mylist - лишь ещё одно имя, указывающее на тот же объект!

del shoplist[0] # Я сделал первую покупку, поэтому удаляю её из списка

print("shoplist:", shoplist)
print("mylist:", mylist)
# Обратите внимание, что и shoplist, и mylist выводят один и тот же список
# без пункта "яблоко", подтверждая тем самым, что они указывают на один объект.

print("Копирование при помощи полной вырезки.")
mylist = shoplist[:] # создаём копию путём полной вырезки
del mylist[0] # удаляем первый элемент

print("shoplist:", shoplist)
print("mylist:", mylist)
# Обратите внимание, что теперь списки разные
# OUT:
'''
Простое присваивание.
shoplist: ['манго', 'морковь', 'бананы']
mylist: ['манго', 'морковь', 'бананы']
Копирование при помощи полной вырезки.
shoplist: ['манго', 'морковь', 'бананы']
mylist: ['морковь', 'бананы']
'''

# 12.8 Ещё о строках
name = 'Swaroop' # Это объект строки

if name.startswith('Swa'):
	print("Да, строка начинается на 'Swa'")

if 'a' in name:
	print("Да, она содержит строку 'a'")

if name.find('war') != -1:
	# find возвращает -1, если подстрока не обнаружена.
	print("Да, она содержит строку 'war'")

delimiter = '_*_'
mylist = ['Бразилия', 'Россия', 'Индия', 'Китай']
print(delimiter.join(mylist))
# OUT:
'''
Да, строка начинается на "Swa"
Да, она содержит строку "a"
Да, она содержит строку "war"
Бразилия_*_Россия_*_Индия_*_Китай
'''

# 13.1 Задача
# Составить программу, которая создаёт резервные копии всех наших важных файлов.

# 13.2 Решение (длинное имя файла, без создания каталога)
import os
import time

# 1. Файлы и каталоги, КОТОРЫЙ НЕОБХОДИМО СКОПИРОВАТЬ, собираются в список.
source = ['"C:\\Users\\Андрей\\Documents\\Simple Sticky Notes"']
# Для имён, содержащих пробелы, необходимо использовать двойные кавычки внутри строки.

# 2. Резервные копии должны храниться в основном каталоге резерва.
target_dir = 'D:\\Backup_files\\Other_files' # КУДА НЕОБХОДИМО СКОПИРОВАТЬ.

# 3. Файлы помещаются в zip-архив.
# 4. Именем для zip-архива служит текущая дата и время.
# Если создать сейчас, то %Y%m%d%H%M%S - 20210816155621 - гггг,мм,дд,чч,мм,сс
target = target_dir + os.sep + time.strftime('%Y%m%d%H%M%S') + '.zip'

# 5. Используем команду "zip" для помещения файлов в zip-архив
zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

# Запускаем создание резервной копии
if os.system(zip_command) == 0:
	print("Резервная копия успешно создана в", target)
else:
	print("Создание резервной копии НЕ УДАЛОСЬ")

# 13.3 Вторая версия (короткое имя файла, с созданием каталога)
import os
import time

# 1. Файлы и каталоги, КОТОРЫЙ НЕОБХОДИМО СКОПИРОВАТЬ, собираются в список.
source = ['"C:\\Users\\Андрей\\Documents\\Simple Sticky Notes"']
# Для имён, содержащих пробелы, необходимо использовать двойные кавычки внутри строки.

# 2. Резервные копии должны храниться в основном каталоге резерва.
target_dir = 'D:\\Backup_files\\Other_files' # КУДА НЕОБХОДИМО СКОПИРОВАТЬ.

# 3. Файлы помещаются в zip-архив.

# 4. Текущая дата служит именем подкаталога в основном каталоге
today = target_dir + os.sep + time.strftime('%Y%m%d')
# Текущее время служит именем zip-архива
now = time.strftime('%H%M%S')
# Создаём каталог, если его ещё нет
if not os.path.exists(today):
	os.mkdir(today) # создание каталога
	print("Каталог успешно создан", today)

# Имя zip-файла
target = today + os.sep + now + '.zip'

# 5. Используем команду "zip" для помещения файлов в zip-архив
zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

# Запускаем создание резервной копии
if os.system(zip_command) == 0:
	print("Резервная копия успешно создана в", target)
else:
	print("Создание резервной копии НЕ УДАЛОСЬ")

# 13.4 Третья версия (имя файла ччммсс + комментарий вводим с клавиатуры,
# с созданием каталога)
import os
import time

# 1. Файлы и каталоги, КОТОРЫЙ НЕОБХОДИМО СКОПИРОВАТЬ, собираются в список.
source = ['"C:\\Users\\Андрей\\Documents\\Simple Sticky Notes"']
# Для имён, содержащих пробелы, необходимо использовать двойные кавычки внутри строки.

# 2. Резервные копии должны храниться в основном каталоге резерва.
target_dir = 'D:\\Backup_files\\Other_files' # КУДА НЕОБХОДИМО СКОПИРОВАТЬ.

# 3. Файлы помещаются в zip-архив.

# 4. Текущая дата служит именем подкаталога в основном каталоге
today = target_dir + os.sep + time.strftime('%Y%m%d')
# Текущее время служит именем zip-архива
now = time.strftime('%H%M%S')
# Запрашиваем комментарий пользователя для имени файла
comment = input("Введите комментарий --> ")
if len(comment) == 0: # проверяем, введён ли комментарий
	target = today + os.sep + now + '.zip'
else:
	target = today + os.sep + now + '_' + \
		comment.replace(' ', '_') + '.zip'
# Создаём каталог, если его ещё нет
if not os.path.exists(today):
os.mkdir(today) # создание каталога
print("Каталог успешно создан", today)

# 5. Используем команду "zip" для помещения файлов в zip-архив
zip_command = "zip -qr {0} {1}".format(target, ' '.join(source))

# Запускаем создание резервной копии
if os.system(zip_command) == 0:
	print("Резервная копия успешно создана в", target)
else:
	print("Создание резервной копии НЕ УДАЛОСЬ")

# 13.7 Процесс разработки программного обеспечения
'''Стадиие создания программы:

• Что (Анализ)
• Как (Проектирование)
• Создание (Реализация)
• Тестирование (Тестирование и Отладка)
• Использование (Развёртывание и Оперирование)
• Поддержка (Усовершенствование)

!!! Помните, Программы выращиваются, а не строятся.
'''

# 14 Объектно-ориентированное программирование (ООП).
# ООП заключаеся в том, чтобы объединять данные и функционал внутри некоего объекта.

# Два основных аспекта ООП – классы и объекты. Класс создаёт новый тип,
# а объекты являются экземплярами класса.
# Когда мы говорим о «переменных типа int», это означает, что переменные, которые
# хранят целочисленные значения, являются экземплярами (объектами) класса int.

# Класс создаётся ключевым словом class. Поля и методы класса записываются в блоке
# кода с отступом.

# 14.1 self
# self - это переменная, которая указывает на сам объект экземпляра класса.
# Python присваивает значение self и почему вам ненужно указывать это значение
# самостоятельно.
# Это также означает, что если какой-либо метод не принимает аргументов, у него
# всё равно будет один аргумент – self.

# 14.2 Классы

# 1. создаём новый класс при помощи оператора class и имени класса.
class Person:
	# 2. блок выражений, формирующих тело класса.
	pass # Пустой блок

# 3. создаём объект-экземпляр класса	
p = Person()
# 4. выясняем тип переменной, просто выводя её на экран
print(p)
# 5. видим, что у нас есть экземпляр класса Person в модуле __main__

# OUT: <__main__.Person object at 0x019F85F0>
# выводится также и адрес в памяти компьютера, где хранится ваш объект - 0x019F85F0

# 14.3 Методы объектов
class Person:
	def sayHi(self):
		print("Привет! Как дела?")

p = Person()
p.sayHi() # можно также записать короче Person().sayHi()
# OUT: Привет! Как дела?

# Здесь мы видим self в действии. Обратите внимание, что метод sayHi не
# принимает параметров, но тем не менее, имеет self в определении функции.

# 14.4 Метод __init__
# Метод __init__ запускается, как только объект класса реализуется.
class Person:
	# 1. определяем метод __init__ так, чтобы он принимал параметр name (наряду с обычным self).
	def __init__(self, name):
		# 2. создаём новое поле с именем name.
		# точка в выражении self.name обозначает, что существует нечто с именем «name»,
		# являющееся частью объекта «self», и другое name – локальная переменная
		self.name = name
	# 3. ...
	def say_hi(self):
		print("Привет! Меня зовут", self.name)

# 4. для создания нового экземпляра p класса Person мы указываем имя класса,
# после которого – аргументы в скобках
p = Person('Swaroop')
p.say_hi() # Можно также записать короче Person('Swaroop').say_hi()
# OUT: Привет! Меня зовут Swaroop

# Метод __init__ мы при этом не вызываем явным образом. В этом и заключается специальная
# роль данного метода.

# После этого мы получаем возможность использовать поле self.name в наших
# методах, что и продемонстрировано в методе say_hi.

# 14.5 Переменные класса и объекта
# Данные, т.е. поля, являются не чем иным, как обычными переменными, заключёнными в
# пространствах имён классов и объектов. Это означает, что их имена действительны
# только в контексте этих классов или объектов.

# Существует два типа полей: переменные класса и переменные объекта, которые различаются
# в зависимости от того, принадлежит ли переменная классу или объекту соответственно.

# Переменные класса разделяемы – доступ к ним могут получать все экземпляры этого класса.
# Переменная класса существует только одна, поэтому когда любой из объектов изменяет
# переменную класса, это изменение отразится и во всех остальных экземплярах того же класса.

# Переменные объекта принадлежат каждому отдельному экземпляру класса. В этом случае
# у каждого объекта есть своя собственная копия поля, т.е. не разделяемая и никоим образом
# не связанная с другими такими же полями в других экземплярах.

class Robot:
	'''Представляет робота с именем.'''
	population = 0 # переменная класса, содержащая количество роботов

	def __init__(self, name):
		'''Инициализация данных.'''
		self.name = name
		print("(Инициализация {0})".format(self.name))

		Robot.population += 1 # при создании, робот добавляется (прибавляется) к переменной 'population'


	def __del__(self):
		'''Уничтожение.'''
		print("{0} уничтожается!".format(self.name))

		Robot.population -= 1 # при уничтожении, робот убирается (вычитается) из переменной 'population'

		if Robot.population == 0:
			print("{0} был последним.".format(self.name))
		else:
			print("Осталось {0:d} работающих роботов.".format( \
				Robot.population))


	def sayHi(self):
		'''Приветствие робота.

		Да, они это могут.'''
		print("Приветствую! Мои хозяева называют меня {0}.".format(self.name))


	def howMany():
		'''Выводит численность роботов.'''
		print("У нас {0:d} роботов.".format(Robot.population))

	howMany = staticmethod(howMany) # присваиваем функции howMany staticmethod без использования декоратора @


droid1 = Robot("R2-D2")
droid1.sayHi()
Robot.howMany()

droid2 = Robot("C-3PO")
droid2.sayHi()
Robot.howMany()

print("\nЗдесь роботы могут проделать какую-то работу.\n")

print("Роботы закончили свою работу. Давайте уничтожим их.")
del droid1
del droid2

Robot.howMany()
# OUT:
'''
(Инициализация R2-D2)
Приветствую! Мои хозяева называют меня R2-D2.
У нас 1 роботов.
(Инициализация C-3PO)
Приветствую! Мои хозяева называют меня C-3PO.
У нас 2 роботов.

Здесь роботы могут проделать какую-то работу.

Роботы закончили свою работу. Давайте уничтожим их.
R2-D2 уничтожается!
Осталось 1 работающих роботов.
C-3PO уничтожается!
C-3PO был последним.
У нас 0 роботов.
'''

# 14.6 Наследование
'''
Одно из главных достоинств объектно-ориентированного программирования заключается в
многократном использовании одного и того же кода, и один из способов этого
достичь – при помощи механизма наследования.

Cоздадим общий класс с именем SchoolMember, а затем сделать так, чтобы классы
преподавателя и студента наследовали этот класс, т.е. чтобы они стали подтипами этого
типа (класса), после чего добавить любые специфические характеристики к этим подтипам.

Когда подтип может быть подставлен в любом месте, где ожидается родительский тип, т.е.
объект считается экземпляром родительского класса, это называется ПОЛИМОРФИЗМОМ.

Класс SchoolMember называют базовым классом или надклассом. Классы Teacher и Student
называют производными классами или подклассами.
'''
class SchoolMember:
	'''Представляет любого человека в школе.'''
	def __init__(self, name, age):
		self.name = name
		self.age = age
		print("(Создан SchoolMember: {0})".format(self.name))


	def tell(self):
		'''Вывести информацию.'''
		print("Имя:'{0}' Возраст:'{1}'".format(self.name, self.age), end=" ")


class Teacher(SchoolMember):
	'''Представляет преподавателя.'''
	def __init__(self, name, age, salary):
		SchoolMember.__init__(self, name, age)
		self.salary = salary
		print("(Создан Teacher: {0})".format(self.name))


	def tell(self):
		SchoolMember.tell(self)
		print("Зарплата: '{0:d}'".format(self.salary))


class Student(SchoolMember):
	'''Представляет студента.'''
	def __init__(self, name, age, marks):
		SchoolMember.__init__(self, name, age)
		self.marks = marks
		print("(Создан Student: {0})".format(self.name))


	def tell(self):
		SchoolMember.tell(self)
		print("Оценки: '{0:d}'".format(self.marks))


t = Teacher("Mrs. Shrividya", 40, 30000)
s = Student("Swaroop", 25, 75)

print() # печатает пустую строку

members = [t, s]
for member in members:
	member.tell() # работает как для преподавателя, так и для студента

# OUT:
'''
(Создан SchoolMember: Mrs. Shrividya)
(Создан Teacher: Mrs. Shrividya)
(Создан SchoolMember: Swaroop)
(Создан Student: Swaroop)
Имя:"Mrs. Shrividya" Возраст:"40" Зарплата: "30000"
Имя:"Swaroop" Возраст:"25" Оценки: "75"
'''

# 14.7 Метаклассы
from abc import *

class SchoolMember(metaclass=ABCMeta):
	'''Представляет любого человека в школе.'''
	def __init__(self, name, age):
		self.name = name
		self.age = age
		print("(Создан SchoolMember: {0})".format(self.name))


	@abstractmethod
	def tell(self):
	'''Вывести информацию.'''
	print('Имя:"{0}" Возраст:"{1}"'.format(self.name, self.age), end=" ")


class Teacher(SchoolMember):
	'''Представляет преподавателя.'''
	def __init__(self, name, age, salary):
		SchoolMember.__init__(self, name, age)
		self.salary = salary
		print("(Создан Teacher: {0})".format(self.name))


	def tell(self):
		SchoolMember.tell(self)
		print("Зарплата: '{0:d}'".format(self.salary))


class Student(SchoolMember):
	'''Представляет студента.'''
	def __init__(self, name, age, marks):
		SchoolMember.__init__(self, name, age)
		self.marks = marks
		print("(Создан Student: {0})".format(self.name))


	def tell(self):
	SchoolMember.tell(self)
	print("Оценки: '{0:d}'".format(self.marks))


t = Teacher("Mrs. Shrividya", 40, 30000)
s = Student("Swaroop", 25, 75)

# m = SchoolMember('abc', 10)
# Это приведёт к ошибке: "TypeError: Can't instantiate abstract class
# SchoolMember with abstract methods tell"

print() # печатает пустую строку

members = [t, s]
for member in members:
	member.tell() # работает как для преподавателя, так и для студента

# OUT:
'''
(Создан SchoolMember: Mrs. Shrividya)
(Создан Teacher: Mrs. Shrividya)
(Создан SchoolMember: Swaroop)
(Создан Student: Swaroop)
Имя:"Mrs. Shrividya" Возраст:"40" Зарплата: "30000"
Имя:"Swaroop" Возраст:"25" Оценки: "75"
'''

# 15 Ввод-вывод
# 15.1 Ввод от пользователя
def reverse(text):
    return text[::-1]

def is_palindrome(text):
    return text == reverse(text)

something = input("Введите текст: ")
something = something.lower()

if (is_palindrome(something)):
    print("Полиндром")
else:
    print("Нет, это не палиндром")

# OUT:
'''
Введите текст: сэр
Нет, это не палиндром

Введите текст: мадам
Да, это палиндром

Введите текст: топот
Да, это палиндром
'''

# 15.2 Файлы
'''
Открывать и использовать файлы для чтения или записи можно путём создания объекта
класса file, а читать/записывать в файл – при помощи его методов read, readline или
write соответственно. Возможность читать или записывать в файл зависит от режима,
указанного при открытии файла. По окончании работы с файлом, нужно вызвать метод
close, чтобы указать Python, что файл больше не используется.
'''
poem = '''\
Программировать весело.
Если работа скучна,
Чтобы придать ей весёлый тон -
	используй Python!
'''

f = open("poem.txt", "w") # открываем для записи (writing)
f.write(poem) # записываем текст в файл
f.close() # закрываем файл

f = open("poem.txt") # если не указан режим, по умолчанию подразумевается
					 # режим чтения 'r' (reading)

while True:
	line = f.readline()
	if len(line) == 0: # Нулевая длина обозначает конец файла (EOF)
		break
	print(line, end="")

f.close() # закрываем файл

# OUT:
'''
Программировать весело.
Если работа скучна,
Чтобы придать ей весёлый тон -
	используй Python!
'''

# 15.3 Pickle (в переводе “соленый огурчик” или просто ”консервация”)
'''
Python предоставляет стандартный модуль с именем pickle, при помощи которого можно
сохранять любой объект Python в файле, а затем извлекать его обратно. Это называется
длительным хранением объекта.
'''
import pickle


# имя файла, в котором мы сохраним объект
shoplistfile = 'shoplist.data'
# список покупок
shoplist = ['яблоки', 'манго', 'морковь']

# Запись в файл
f = open(shoplistfile, 'wb')
pickle.dump(shoplist, f) # помещаем объект в файл
f.close()

del shoplist # уничтожаем переменную shoplist

# Считываем из хранилища
f = open(shoplistfile, 'rb')
storedlist = pickle.load(f) # загружаем объект из файла
print(storedlist)

# в итоге выполнения программы создается файл с именем 'shoplist.data'

# OUT:
'''
['яблоки', 'манго', 'морковь']
'''

# 16 Исключения
# Исключения возникают тогда, когда в программе возникает некоторая исключительная ситуация.

# 16.1 Ошибки
# Обратите внимание на заглавную букву функции Print(). В этом случае Python поднимает синтаксическую
# ошибку.
>>> Print("Привет, Мир!")
Traceback (most recent call last):
	File "<pyshell#0>", line 1, in <module>
		Print("Привет, Мир!")
NameError: name 'Print' is not defined
>>> print("Привет, Мир!")
Привет, Мир!

# 16.2 Исключения
# Попытаемся считать что-либо от пользователя. Нажмите Сtrl-D (или Ctrl+Z в Windows)
# и посмотрите, что произойдёт.
>>> s = input("Введите что-нибудь --> ")
Введите что-нибудь -->
Traceback (most recent call last):
	File "<pyshell#2>", line 1, in <module>
		s = input("Введите что-нибудь --> ")
EOFError: EOF when reading a line
# Python поднимает ошибку с именем EOFError, что означает, что он обнаружил символ
# конца файла (который вводится при помощи Ctrl-D (или Ctrl+Z в Windows)) там, где не ожидал.

# 16.3 Обработка исключений
'''
Обрабатывать исключения можно при помощи оператора try..except. При этом все
обычные команды помещаются внутрь try-блока, а все обработчики исключений – в except-блок.
'''
try:
	text = input("Введите что-нибудь --> ")
except EOFError:
	print("Ну зачем вы сделали мне EOF?")
except KeyboardInterrupt:
	print("Вы отменили операцию.")
else:
	print("Вы ввели {0}".format(text))

# OUT:
'''
Введите что-нибудь --> # Нажмите Ctrl-D (или Ctrl+Z в Windows), затем Enter
Ну зачем вы сделали мне EOF?

Введите что-нибудь --> # Нажмите Ctrl-C
Вы отменили операцию.

Введите что-нибудь --> без ошибок
Вы ввели без ошибок
'''

# Можно также добавить пункт else к соответствующему блоку try..except. Этот пункт
# будет выполнен тогда, когда исключений не возникает.

# 16.4 Вызов исключения
'''
Исключение можно поднять при помощи оператора raise, передав ему имя ошибки/исключения,
а также объект исключения, который нужно выбросить.

Вызываемая ошибка или исключение должна быть классом, который прямо или непрямо
является производным от класса Exception.
'''
class ShortInputException(Exception):
	'''Пользовательский класс исключения.'''
	def __init__(self, length, atleast):
		Exception.__init__(self)
		self.length = length
		self.atleast = atleast

try:
	text = input("Введите что-нибудь --> ")
	if len(text) < 3:
		raise ShortInputException(len(text), 3)
	# Здесь может происходить обычная работа
except EOFError:
	print("Ну зачем вы сделали мне EOF?")
except ShortInputException as ex:
	print("ShortInputException: Длина введённой строки -- {0}; \
		ожидалось, как минимум, {1}".format(ex.length, ex.atleast))
else:
	print("Не было исключений.")

# OUT:
'''
Введите что-нибудь --> а
ShortInputException: Длина введённой строки -- 1; ожидалось, как минимум, 3

Введите что-нибудь --> абв
Не было исключений.
'''

# 16.5 Try .. Finally
'''
Представим, что в программе происходит чтение файла и необходимо убедиться, что объект
файла был корректно закрыт и что не возникло никакого исключения. Этого можно
достичь с применением блока finally.
'''
import time

try:
	f = open('poem.txt')
	while True: # наш обычный способ читать файлы
		line = f.readline()
		if len(line) == 0:
			break
		print(line, end="")
		time.sleep(2) # Ожидание 2 сек
except KeyboardInterrupt:
	print("!! Вы отменили чтение файла.")
finally:
	f.close()
	print("(Очистка: Закрытие файла)")

# OUT:
'''
Программировать весело
Если работа скучна,
Чтобы придать ей весёлый тон -
!! Вы отменили чтение файла.
(Очистка: Закрытие файла)
'''

# 16.6 Операторы with..as
'''
Типичной схемой является запрос некоторого ресурса в блоке try с последующим освобождением этого
ресурса в блоке finally. Для того, чтобы сделать это более «чисто», существуют операторы with..as
'''

with open("poem.txt") as f:
	for line in f:
		print(line, end="")
'''
Вывод должен быть таким же, как и в предыдущем примере. Разница лишь в том, что здесь
мы используем функцию open с оператором with – этим мы оставляем автоматическое
закрытие файла под ответственность with open.
'''

# 17 Стандартная библиотека
# 17.1 Модуль sys
'''
Модуль sys содержит функциональность, характерную для системы. Так мы видели, что список
sys.argv содержит аргументы командной строки.

Предположим, нам нужно узнать версию используемой команды Python с тем, чтобы, к примеру,
убедиться в том, что мы используем как минимум версию 3. Модуль sys предоставляет такую
возможность.
'''
>>> import sys
>>> sys.version_info
# OUT:
'''
sys.version_info(major=3, minor=8, micro=8, releaselevel='final', serial=0)
'''
>>> sys.version_info[0] >= 3
# OUT:
'''
True
'''

# Для того, чтобы убедиться, что программа будет выполняться только в Python 3.0:
import sys, warnings

if sys.version_info[0] < 3:
	warnings.warn("Для выполнения этой программы необходима как минимум \
					версия Python 3.0",
		RuntimeWarning)
else:
	print("Нормальное продолжение")

# OUT:
'''
Если открыть с помощью Python 2:
versioncheck.py:6: Для выполнения этой программы необходима как минимум
	,→версия Python 3.0
	RuntimeWarning)

Если открыть с помощью Python 3:
Нормальное продолжение
'''

# 17.2 Модуль loggin
'''
Представьте ситуацию, когда необходимо сохранить некоторые отладочные или другие
важные сообщения где-нибудь, чтобы иметь возможность позже проверить, отработала
ли программа, как ожидалось.

Мы используем три модуля из стандартной библиотеки: модуль os для взаимодействия с
операционной системой, модуль platform для получения информации о платформе (т.е.
операционной системе) и модуль logging для сохранения лога.
'''
import os, platform, logging

if platform.platform().startswith('Windows'):
	logging_file = os.path.join(os.getenv('HOMEDRIVE'), \
		os.getenv('HOMEPATH'), \
		'test.log')
else:
	logging_file = os.path.join(os.getenv('HOME'), 'test.log')

print("Сохраняем лог в", logging_file)

logging.basicConfig(
	level=logging.DEBUG,
	format='%(asctime)s : %(levelname)s : %(message)s',
	filename = logging_file,
	filemode = 'w',
)

logging.debug("Начало программы")
logging.info("Какие-то действия")
logging.warning("Программа рушится")

# OUT:
'''
Сохраняем лог в C:\\Users\\swaroop\\test.log
'''
# Если открыть файл test.log, он будет выглядеть примерно так:
'''
2012-10-26 16:52:41,457 : DEBUG : Начало программы
2012-10-26 16:52:41,474 : INFO : Какие-то действия
2012-10-26 16:52:41,475 : WARNING : Программа рушится
'''

# 18 Дополнительно
# 18.1 Передача кортежей
>>> def get_error_details():
 		return (2, "описание ошибки No2")

>>> errnum, errstr = get_error_details()
>>> errnum
# OUT:
'''
2
'''
>>> errstr
# OUT:
'''
"описание ошибки No2"
'''
# Использование выражения «a, b = <некоторое выражение>» интерпретирует результат как
# кортеж из двух значений.

# Чтобы интерпретировать результат как «(a, <всё остальное>)», нужно просто поставить
# звёздочку, как это делалось для параметров функций:
>>> a, *b = [1, 2, 3, 4]
>>> a
1
>>> b
[2, 3, 4]

# Это также подразумевает, что поменять местами два значения в Python быстрее всего
# можно так:
>>> a = 5; b = 8
>>> a, b = b, a
>>> a, b
(8, 5)

# 18.2 Специальные методы (magic methods)
# Специальные методы служат для того, чтобы имитировать поведение встроенных типов данных.
	НАЗВАНИЕ 							ОПИСАНИЕ
__init__(self, …) 		Этот метод вызывается прямо перед тем, как вновь созданный
						объект возвращается для использования.

__del__(self)			Вызывается перед уничтожением объекта.

__str__(self) 			Вызывается при использовании функции print или str().

__lt__(self, other) 	Вызывается, когда используется оператор «меньше» (<).
						Существуют и аналогичные методы для всех операторов (+, >,
						и т.д.).

__getitem__(self, key)  Вызывается при использовании оператора индексирования
						x[индекс].

__len__(self) 			Вызывается при обращении к встроенной функции len() для
						объекта-последовательности.

# 18.3 Блоки в одно выражение
'''
Если блок команд содержит только одно выражение, его можно указывать в одной строке
с условным оператором или, скажем, оператором цикла.
'''
>>> flag = True
>>> if flag: print("Да")
Да

# 18.4 Lambda-формы
'''
Ключевое слово lambda используется для создания функций и возврата их значения во
время выполнения программы. lambda принимает параметр, за которым следует одно
выражение, которое становится телом функции, а значение этого выражения возвращается
новой функцией.

В данном случае мы хотим провести сортировку по собственному принципу, список будет
отсортирован по ключу 'y'.
'''
points = [ { 'x' : 2, 'y' : 3 }, { 'x' : 4, 'y' : 1 } ]
points.sort(key=lambda i : i['y'])
print(points)

# OUT: [{'x': 4, 'y': 1}, {'x': 2, 'y': 3}]

# 18.5 Генераторы списков
'''
Генераторы списков служат для создания новых списков на основе существующих. Представьте,
что имеется список чисел, на основе которого требуется получить новый список, состоящий
из всех чисел, умноженных на 2, но только при условии, что само число больше 2.
'''
listone = [2, 3, 4]
listtwo = [2*i for i in listone if i > 2]
print(listtwo) # переменная будет в новом списке 'listtwo' и будет умножена на 2, если она > 2

# OUT: [6, 8]

# 18.6 Передача кортежей и словарей в функции
'''
Для получения параметров, переданных функции, в виде кортежа или словаря, существуют
специальные приставки «*» - args или «**» - kwargs соответственно. Это особенно полезно
в случаях, когда функция может принимать переменное число параметров.
'''
>>> def powersum(power, *args):
... 	'''Возвращает сумму аргументов, возведённых в указанную степень.'''
... 	total = 0
... 	for i in args:
... 		total += pow(i, power)
... 	return total
...
>>> powersum(2, 3, 4) # степень - 2, кортеж чисел - (3, 4)
25

>>> powersum(2, 10) # степень - 2, кортеж чисел - (10,)
100
'''
Поскольку перед переменной args указана приставка «*», все дополнительные аргументы,
переданные функции, сохранятся в args в виде кортежа. В случае использования приставки
«**» все дополнительные параметры будут рассматриваться как пары ключ/значение в словаре.
'''

# 18.7 exec и eval
'''
Функция exec служит для выполнения команд Python, содержащихся в строке или файле, в
отличие от самого текста программы
'''
>>> exec('print("Здравствуй, Мир!")')
Здравствуй, Мир!
'''
Аналогично, функция eval позволяет вычислять корректные выражения Python, содержащиеся
в строке.
'''
>>> eval('2*3')
6

# 18.8 Оператор assert
'''
Оператор assert существует для того, чтобы указать, что нечто является истиной. Например,
если требуется гарантировать, что в списке будет хотя бы один элемент, и вызвать ошибку,
если это не так, то оператор assert идеально подойдёт для такой задачи. Когда заявленное
выражение ложно, вызывается ошибка AssertionError. Метод pop() возвращает последний
элемент списка, одновременно удаляя его оттуда.
'''
>>> mylist = ['item']
>>> assert len(mylist) >= 1
>>> mylist.pop()
'item'
>>> mylist
[]
>>> assert len(mylist) >= 1
Traceback (most recent call last):
File "<stdin>", line 1, in <module>
AssertionError

# 18.9 Функция repr
'''
Функция repr используется для получения канонического строкового представления
объекта. Любопытно, что в большинстве случаев eval(repr(object)) == object.
'''
>>> i = []
>>> i.append('item')
>>> repr(i)
"['item']"
>>> eval(repr(i))
['item']
>>> eval(repr(i)) == i
True
'''
функция repr служит для получения печатаемого представления объекта. Определив метод
__repr__ в собственном классе, можно указать, что он будет возвращать по вызову функции
repr.
'''

# 18.10 Управляющие последовательности (экранирование).
'''
Попробуйте ответить на вопрос: Как указать строку, содержащую одинарную кавычку (')?
Например, строку «What's your name?». Её ведь нельзя записать просто как «'What's
your name?'», потому что тогда Python не сможет определить, где начало строки, и где
конец. В таком случае придётся каким-то образом указать, что данная одинарная кавычка
не обозначает конца строки. Это можно сделать при помощи так называемой управляющей
последовательности. Укажите одинарную кавычку как \' – через обратную косую черту.
Теперь наша строка будет выглядеть так: 'What\'s your name?'.

Другой способ записи такой специфической строки – "What's your name?", т.е. с
использованием двойных кавычек. Аналогично следует использовать управляющую
последовательность для вставки двойной кавычки в строку, ограниченную двойными кавычками.
Сама же обратная наклонная черта указывается управляющей последовательностью
\\.

А как записать двустрочную строку? Один из вариантов нам уже знаком – заключить
строку в тройные кавычки, как было показано ранее. Но есть и другой – использовать
управляющую последовательность для символа перевода строки \n. Например: «Это
первая строка\nЭто вторая строка». Полезно знать ещё одну управляющую последовательность
– табуляцию (\t). Управляющих последовательностей существует намного больше, но здесь
упомянуты только наиболее важные.

Следует отметить, что одинарная наклонная черта в конце строки лишь указывает на то,
что продолжение идёт строкой ниже, но не вставляет перевода строки. Например:

"Это первое предложение. \
Это второе предложение."

эквивалентно записи "Это первое предложение. Это второе предложение.".
'''

# 18.11 Необрабатываемые строки
'''
Для записи строки, в которой не будет проводиться никакой специальной обработки, как,
например, управляющих последовательностей, перед строкой указывается приставка «r»
или «R». Например, r"Перевод строки обозначается \n".
'''

print(Fore.WHITE)
print("Program finish")

input()
